<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>zeebe-node</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">zeebe-node</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> zeebe-node</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="zeebe-node-js-client">Zeebe Node.js Client</h1>
				<p><a href="https://opensource.org/licenses/Apache-2.0"><img src="https://img.shields.io/badge/License-Apache%202.0-blue.svg" alt="License"></a>
				<a href="https://circleci.com/gh/creditsenseau/zeebe-client-node-js/tree/master"><img src="https://circleci.com/gh/creditsenseau/zeebe-client-node-js/tree/master.svg?style=svg" alt="CircleCI"></a></p>
				<p>This is a Node.js gRPC client for <a href="https://zeebe.io">Zeebe</a>. It is written in TypeScript and transpiled to JavaScript in the <code>dist</code> directory.</p>
				<p>Comprehensive API documentation is available <a href="https://creditsenseau.github.io/zeebe-client-node-js/">online</a> and in the <code>docs</code> subdirectory.</p>
				<p>Docker-compose configurations for Zeebe are available at <a href="https://github.com/zeebe-io/zeebe-docker-compose">https://github.com/zeebe-io/zeebe-docker-compose</a>.</p>
				<h2 id="versioning">Versioning</h2>
				<p>To enable that the client libraries can be easily supported to the Zeebe server we are remapping the version numbers, so that Major, Minor match the server application. Patches will be independent and indicate client updates.</p>
				<p>NPM Package version 0.21.x supports Zeebe 0.21.x</p>
				<p>NPM Package version 0.20.x supports Zeebe 0.20.x</p>
				<p>NPM Package version 0.19.x supports Zeebe 0.19.x</p>
				<p>NPM Package version 2.x.x supports Zeebe 0.18.</p>
				<p>NPM Package version 1.x.x supports Zeebe 0.15/0.16.</p>
				<h2 id="type-difference-from-other-zeebe-clients">Type difference from other Zeebe clients</h2>
				<p>Protobuf fields of type <code>int64</code> are serialised as type string in the Node library. These fields are serialised as numbers (long) in the Go and Java client. See <a href="https://github.com/grpc/grpc/issues/7229">grpc/#7229</a> for why the Node library serialises them as string. The Workflow instance key, and other fields that are of type long in other client libraries, are type string in this library. Fields of type <code>int32</code> are serialised as type number in the Node library.</p>
				<h2 id="scaffolding-code-from-a-bpm-file">Scaffolding code from a BPM file</h2>
				<p>You can scaffold your worker code from a BPMN file with the <code>bin/zeebe-node-cli</code> command. Pass in the path to the BPMN file, and it will produce a file to implement it.</p>
				<h2 id="example-use">Example Use</h2>
				<h3 id="add-the-library-to-your-project">Add the Library to your Project</h3>
				<pre><code class="language-bash">npm i zeebe-node</code></pre>
				<h3 id="get-broker-topology">Get Broker Topology</h3>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> ZB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zeebe-node'</span>)

;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span> (</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient(<span class="hljs-string">'localhost:26500'</span>)
    <span class="hljs-keyword">const</span> topology = <span class="hljs-keyword">await</span> zbc.topology()
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(topology, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>))

    <span class="hljs-keyword">let</span> workflows = <span class="hljs-keyword">await</span> zbc.listWorkflows()
    <span class="hljs-built_in">console</span>.log(workflows)
})()</code></pre>
				<h3 id="deploy-a-workflow">Deploy a workflow</h3>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> ZB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zeebe-node'</span>)

;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span> (</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient(<span class="hljs-string">'localhost:26500'</span>)

    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> zbc.deployWorkflow(<span class="hljs-string">'./domain-mutation.bpmn'</span>)

    <span class="hljs-built_in">console</span>.log(res)
})()</code></pre>
				<h3 id="client-side-grpc-retry-in-zbclient">Client-side gRPC retry in ZBClient</h3>
				<p>If a gRPC command method fails in the ZBClient - such as <code>ZBClient.deployWorkflow</code> or <code>ZBClient.topology()</code>, the underlying gRPC library will throw an exception.</p>
				<p>If no workers have been started, this can be fatal to the process if it is not handled by the application logic. This is especially an issue when a worker container starts before the Zeebe gRPC gateway is available to service requests, and can be inconsistent as this is a race condition.</p>
				<p>To mitigate against this, the Node client implements some client-side gRPC operation retry logic by default. This can be configured, including disabled, via configuration in the client constructor.</p>
				<ul>
					<li>Operations retry, but only for <a href="https://github.com/grpc/grpc/blob/master/doc/statuscodes.md">gRPC error codes 8 and 14</a> - indicating resource exhaustion (8) or transient network failure (14). Resource exhaustion occurs when the broker starts backpressure due to latency because of load. Network failure can be caused by passing in an unresolvable gateway address (<code>14: DNS Resolution failed</code>), or by the gateway not being ready yet (<code>14: UNAVAILABLE: failed to connect to all addresses</code>).</li>
					<li>Operations that fail for other reasons, such as deploying an invalid bpmn file or cancelling a workflow that does not exist, do not retry.</li>
					<li>Retry is enabled by default, and can be disabled by passing { retry: false } to the client constructor.</li>
					<li><code>maxRetries</code> and <code>maxRetryTimeout</code> are also configurable through the constructor options. By default, if not supplied, the values are:</li>
				</ul>
				<pre><code class="language-TypeScript"><span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient(gatewayAddress, {
    retry: <span class="hljs-literal">true</span>,
    maxRetries: <span class="hljs-number">50</span>,
    maxRetryTimeout: <span class="hljs-number">5000</span>
})</code></pre>
				<p>Retry is provided by <a href="https://www.npmjs.com/package/promise-retry">promise-retry</a>, and the back-off strategy is simple ^2.</p>
				<p>Additionally, the gRPC Client will continually reconnect when in a failed state, such as when the gateway goes away due to pod rescheduling on Kubernetes.</p>
				<h3 id="onready-onconnectionerror-and-connected">onReady(), onConnectionError(), and connected</h3>
				<p>The client has a <code>connected</code> property that can be examined to determine if it has a gRPC connection to the gateway.</p>
				<p>The client and the worker can take an optional <code>onReady()</code> and <code>onConnectionError()</code> handler in their options, like this:</p>
				<pre><code class="language-TypeScript"><span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient({
    onReady: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Connected!`</span>),
    onConnectionError: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Disconnected!`</span>)
})

<span class="hljs-keyword">const</span> zbWorker = zbc.createWorker(
    <span class="hljs-literal">null</span>,
    <span class="hljs-string">'demo-service'</span>,
    handler,
    {
        onReady: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Worker connected!`</span>),
        onConnectionError: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Worker disconnected!`</span>)
    })</code></pre>
				<p>These handlers are called whenever the gRPC channel is established or lost. As the channel will jitter when it is lost, there is a <code>connectionTolerance</code> property that determines how long the connection must be in a connected or failed state before the handler is called. By default this is 3000ms. You can specify another value like this:</p>
				<pre><code class="language-TypeScript"><span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient({
    onReady: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Connected!`</span>),
    onConnectionError: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Disconnected!`</span>),
    connectionTolerance: <span class="hljs-number">5000</span>
})

<span class="hljs-keyword">const</span> zbWorker = zbc.createWorker(
    <span class="hljs-literal">null</span>,
    <span class="hljs-string">'demo-service'</span>,
    handler,
    {
        onReady: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Worker connected!`</span>),
        onConnectionError: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Worker disconnected!`</span>),
        connectionTolerance: <span class="hljs-number">35000</span>
    })</code></pre>
				<h3 id="tls">TLS</h3>
				<p>Enable a secure connection by setting <code>useTLS: true</code>:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient(tlsProxiedGatewayAddress, {
    useTLS: <span class="hljs-literal">true</span>,
})</code></pre>
				<h3 id="oauth">OAuth</h3>
				<p>In case you need to connect to a secured endpoint with OAuth, you can pass in OAuth credentials. This will enable TLS (unless you explicitly disable it with <code>useTLS: false</code>), and handle the OAuth flow to get / renew a JWT:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient(<span class="hljs-string">"my-secure-broker.io:443"</span>, {
    oAuth: {
        url: <span class="hljs-string">"https://your-auth-endpoint/oauth/token"</span>,
        audience: <span class="hljs-string">"my-secure-broker.io"</span>,
        clientId: <span class="hljs-string">"myClientId"</span>,
        clientSecret:
        <span class="hljs-string">"randomClientSecret"</span>,
        cacheOnDisk: <span class="hljs-literal">false</span>
    }
}</code></pre>
				<p>The <code>cacheOnDisk</code> option will cache the token on disk, which can be useful in development if you are restarting the service frequently.</p>
				<h3 id="camunda-cloud">Camunda Cloud</h3>
				<p>You can connect to Camunda Cloud by using the <code>camundaCloud</code> configuration option, using the <code>clusterId</code>, <code>clientSecret</code>, and <code>clientId</code> from the Camunda Cloud Console, like this:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient({
    camundaCloud: {
        clientId,
        clientSecret,
        clusterId,
    },
})</code></pre>
				<p>That&#39;s it! Under the hood, the client lib will construct the OAuth configuration for Camunda Cloud and set the gateway address and port for you.</p>
				<h2 id="zero-conf-constructor">Zero-Conf constructor</h2>
				<p>The ZBClient has a 0-parameter constructor that takes the config from the environment. This is useful for injecting secrets into your app via the environment, and switching between development and production environments with no change to code.</p>
				<p>To use the zero-conf constructor, you create the client like this:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZBClient()</code></pre>
				<p>With no relevant environment variables set, it will default to localhost on the default port with no TLS.</p>
				<p>The following environment variable configurations are possible with the Zero-conf constructor:</p>
				<p>Camunda Cloud:</p>
				<pre><code><span class="hljs-attribute">ZEEBE_GATEWAY_ADDRESS</span>
ZEEBE_CLIENT_SECRET
ZEEBE_CLIENT_ID</code></pre><p>Self-hosted or local broker (no TLS or OAuth):</p>
				<pre><code>ZEEBE_GATEWAY_ADDRESS</code></pre><p>Self-hosted or local broker with OAuth + TLS:</p>
				<pre><code><span class="hljs-attribute">ZEEBE_CLIENT_ID</span>
ZEEBE_CLIENT_SECRET
ZEEBE_TOKEN_AUDIENCE
ZEEBE_AUTHORIZATION_SERVER_URL
ZEEBE_GATEWAY_ADDRESS</code></pre><h3 id="create-a-task-worker">Create a Task Worker</h3>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> ZB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zeebe-node'</span>)

<span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient(<span class="hljs-string">'localhost:26500'</span>)

<span class="hljs-keyword">const</span> zbWorker = zbc.createWorker(<span class="hljs-literal">null</span>, <span class="hljs-string">'demo-service'</span>, handler)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span>(<span class="hljs-params">job, complete</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Task variables'</span>, job.variables)

    <span class="hljs-comment">// Task worker business logic goes here</span>
    <span class="hljs-keyword">const</span> updateToBrokerVariables = {
        <span class="hljs-attr">updatedProperty</span>: <span class="hljs-string">'newValue'</span>,
    }

    complete(updateToBrokerVariables)
}</code></pre>
				<p>Here is an example job:</p>
				<pre><code class="language-javascript">
{ <span class="hljs-attr">key</span>: <span class="hljs-string">'578'</span>,
  <span class="hljs-attr">type</span>: <span class="hljs-string">'demo-service'</span>,
  <span class="hljs-attr">jobHeaders</span>:
   { <span class="hljs-attr">workflowInstanceKey</span>: <span class="hljs-string">'574'</span>,
     <span class="hljs-attr">bpmnProcessId</span>: <span class="hljs-string">'test-process'</span>,
     <span class="hljs-attr">workflowDefinitionVersion</span>: <span class="hljs-number">1</span>,
     <span class="hljs-attr">workflowKey</span>: <span class="hljs-string">'3'</span>,
     <span class="hljs-attr">elementId</span>: <span class="hljs-string">'ServiceTask_0xdwuw7'</span>,
     <span class="hljs-attr">elementInstanceKey</span>: <span class="hljs-string">'577'</span> },
  <span class="hljs-attr">customHeaders</span>: <span class="hljs-string">'{}'</span>,
  <span class="hljs-attr">worker</span>: <span class="hljs-string">'test-worker'</span>,
  <span class="hljs-attr">retries</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">deadline</span>: <span class="hljs-string">'1546915422636'</span>,
  <span class="hljs-attr">variables</span>: { <span class="hljs-attr">testData</span>: <span class="hljs-string">'something'</span> } }
</code></pre>
				<p>The worker can be configured with options. Shown below are the defaults that apply if you don&#39;t supply them:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> workerOptions = {
    <span class="hljs-attr">maxActiveJobs</span>: <span class="hljs-number">32</span>, <span class="hljs-comment">// the number of simultaneous tasks this worker can handle</span>
    timeout: <span class="hljs-number">1000</span>, <span class="hljs-comment">// the maximum amount of time the broker should allow this worker to complete a task</span>
}

<span class="hljs-keyword">const</span> onConnectionError = <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(err) <span class="hljs-comment">// Called when the connection to the broker cannot be established, or fails</span>

<span class="hljs-keyword">const</span> zbWorker = zbc.createWorker(
    <span class="hljs-string">'test-worker'</span>,
    <span class="hljs-string">'demo-service'</span>,
    handler,
    workerOptions,
    onConnectionError
)</code></pre>
				<h4 id="unhandled-exceptions-in-task-handlers">Unhandled Exceptions in Task Handlers</h4>
				<p>When a task handler throws an unhandled exception, the library will fail the job. Zeebe will then retry the job according to the retry settings of the task. Sometimes you want to halt the entire workflow so you can investigate. To have the library cancel the workflow on an unhandled exception, pass in <code>{failWorkflowOnException: true}</code> to the <code>createWorker</code> call:</p>
				<pre><code class="language-typescript">zbc.createWorker(<span class="hljs-string">'test-worker'</span>, <span class="hljs-string">'console-log'</span>, maybeFaultyHandler, {
    failWorkflowOnException: <span class="hljs-literal">true</span>,
})</code></pre>
				<h3 id="completing-tasks-with-success-or-failure">Completing tasks with success or failure</h3>
				<p>To complete a task, the task worker handler function receives a <code>complete</code> method. This method has a <code>success</code> and a <code>failure</code> method (as well as being able to be called directly). Calling the method directly - <code>complete()</code> is the same as calling <code>complete.success()</code>.</p>
				<p>Call <code>complete.success()</code> passing in a optional plain old JavaScript object (POJO) - a key:value map. These are variable:value pairs that will be used to update the workflow state in the broker. They will be merged with existing values. You can set an existing key to <code>null</code> or <code>undefined</code>, but there is no way to delete a key.</p>
				<p>Call <code>complete.failure()</code> to fail the task. You must pass in a string message describing the failure. The client library decrements the retry count, and the broker handles the retry logic. If the failure is a hard failure and should cause an incident to be raised in Operate, then pass in <code>0</code> for the optional second parameter, <code>retries</code>:</p>
				<pre><code class="language-javascript">complete.failure(<span class="hljs-string">'This is a critical failure and will raise an incident'</span>, <span class="hljs-number">0</span>)</code></pre>
				<h3 id="long-polling">Long polling</h3>
				<p>With Zeebe 0.21 onward, long polling is supported for clients, and is used by default. Rather than polling continuously for work and getting nothing back, a client can poll once and leave the request open until work appears. This reduces network traffic and CPU utilization in the server. Every JobActivation Request is appended to the event log, so continuous polling can significantly impact broker performance, especially when an exporter is loaded (see <a href="https://github.com/creditsenseau/zeebe-client-node-js/issues/64#issuecomment-520233275">here</a>).</p>
				<p>The default long polling period is 60000ms (60s).</p>
				<p>To use a different long polling period, pass in a long poll timeout in milliseconds to the client. All workers created with that client will use it. Alternatively, set a period per-worker.</p>
				<p>Long polling for workers is configured in the ZBClient like this:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZBClient(<span class="hljs-string">'serverAddress'</span>, {
    longPoll: <span class="hljs-number">600000</span>, <span class="hljs-comment">// Ten minutes in millis - inherited by workers</span>
})

<span class="hljs-keyword">const</span> longPollingWorker = zbc.createWorker(<span class="hljs-literal">null</span>, <span class="hljs-string">'task-type'</span>, handler, {
    longPoll: <span class="hljs-number">120000</span>, <span class="hljs-comment">// override client, poll 2m</span>
})</code></pre>
				<h3 id="start-a-workflow-instance">Start a Workflow Instance</h3>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> ZB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zeebe-node'</span>)

;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span> (</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient(<span class="hljs-string">'localhost:26500'</span>)
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> zbc.createWorkflowInstance(<span class="hljs-string">'test-process'</span>, {
        <span class="hljs-attr">testData</span>: <span class="hljs-string">'something'</span>,
    })
    <span class="hljs-built_in">console</span>.log(result)
})()</code></pre>
				<p>Example output:</p>
				<pre><code class="language-javascript">
{ <span class="hljs-attr">workflowKey</span>: <span class="hljs-string">'3'</span>,
  <span class="hljs-attr">bpmnProcessId</span>: <span class="hljs-string">'test-process'</span>,
  <span class="hljs-attr">version</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">workflowInstanceKey</span>: <span class="hljs-string">'569'</span> }
</code></pre>
				<h3 id="publish-a-message">Publish a Message</h3>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient(<span class="hljs-string">'localhost:26500'</span>)
zbc.publishMessage({
    <span class="hljs-attr">correlationKey</span>: <span class="hljs-string">'value-to-correlate-with-workflow-variable'</span>,
    <span class="hljs-attr">messageId</span>: uuid.v4(),
    <span class="hljs-attr">name</span>: <span class="hljs-string">'message-name'</span>,
    <span class="hljs-attr">variables</span>: { <span class="hljs-attr">valueToAddToWorkflowVariables</span>: <span class="hljs-string">'here'</span>, <span class="hljs-attr">status</span>: <span class="hljs-string">'PROCESSED'</span> },
    <span class="hljs-attr">timeToLive</span>: <span class="hljs-number">10000</span>,
})</code></pre>
				<p>You can also publish a message targeting a <a href="https://github.com/zeebe-io/zeebe/issues/1858">Message Start Event</a>.
				In this case, the correlation key is optional, and all Message Start events that match the <code>name</code> property will receive the message.</p>
				<p>You can use the <code>publishStartMessage()</code> method to publish a message with no correlation key (it will be set to a random uuid in the background):</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZB.ZBClient(<span class="hljs-string">'localhost:26500'</span>)
zbc.publishStartMessage({
    <span class="hljs-attr">messageId</span>: uuid.v4(),
    <span class="hljs-attr">name</span>: <span class="hljs-string">'message-name'</span>,
    <span class="hljs-attr">variables</span>: { <span class="hljs-attr">initialWorkflowVariable</span>: <span class="hljs-string">'here'</span> },
    <span class="hljs-attr">timeToLive</span>: <span class="hljs-number">10000</span>,
})</code></pre>
				<p>Both normal messages and start messages can be published idempotently by setting both the <code>messageId</code> and the <code>correlationKey</code>. They will only ever be correlated once. See: <a href="https://github.com/zeebe-io/zeebe/issues/1012">A message can be published idempotent</a>.</p>
				<h3 id="graceful-shutdown">Graceful Shutdown</h3>
				<p>To drain workers, call the <code>close()</code> method of the ZBClient. This causes all workers using that client to stop polling for jobs, and returns a Promise that resolves when all active jobs have either finished or timed out.</p>
				<pre><code class="language-javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Closing client...'</span>)
zbc.close().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'All workers closed'</span>))</code></pre>
				<h3 id="generating-typescript-constants-for-bpmn-processes">Generating TypeScript constants for BPMN Processes</h3>
				<p>Message names and Task Types are untyped magic strings. The <code>BpmnParser</code> class provides a static method <code>generateConstantsForBpmnFiles()</code>.
				This method takes a filepath and returns TypeScript definitions that you can use to avoid typos in your code, and to reason about the completeness of your task worker coverage.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> ZB = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zeebe-node'</span>)
;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span> (</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">await</span> ZB.BpmnParser.generateConstantsForBpmnFiles(workflowFile))
})()</code></pre>
				<p>This will produce output similar to:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// Autogenerated constants for msg-start.bpmn</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> TaskType = {
    CONSOLE_LOG = <span class="hljs-string">"console-log"</span>
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> MessageName = {
    MSG_EMIT_FRAME = <span class="hljs-string">"MSG-EMIT_FRAME"</span>,
    MSG_START_JOB = <span class="hljs-string">"MSG-START_JOB"</span>
};</code></pre>
				<h2 id="logging">Logging</h2>
				<p>Control the log output for the client library by setting the ZBClient log level. Valid log levels are <code>NONE</code> (supress all logging), <code>ERROR</code> (log only exceptions), <code>INFO</code> (general logging), or <code>DEBUG</code> (verbose logging). You can set this in the client constructor:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZBClient(<span class="hljs-string">'localhost'</span>, { loglevel: <span class="hljs-string">'DEBUG'</span> })</code></pre>
				<p>And also via the environment:</p>
				<pre><code class="language-bash">ZEEBE_NODE_LOG_LEVEL=<span class="hljs-string">'ERROR'</span> node start.js</code></pre>
				<p>By default the library uses <code>console.info</code> and <code>console.error</code> for logging. You can also pass in a custom logger, such as <a href="https://github.com/pinojs/pino">pino</a>:</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'pino'</span>)()
<span class="hljs-keyword">const</span> zbc = <span class="hljs-keyword">new</span> ZBClient(<span class="hljs-string">'0.0.0.0:26500'</span>, { stdout: logger })</code></pre>
				<h2 id="developing">Developing</h2>
				<p>The source is written in TypeScript in <code>src</code>, and compiled to ES6 in the <code>dist</code> directory.</p>
				<p>To build:</p>
				<pre><code class="language-bash">npm run build</code></pre>
				<p>To start a watcher to build the source and API docs while you are developing:</p>
				<pre><code class="language-bash">npm run dev</code></pre>
				<h3 id="tests">Tests</h3>
				<p>Tests are written in Jest, and live in the <code>src/__tests__</code> directory. To run the unit tests:</p>
				<pre><code class="language-bash">npm t</code></pre>
				<p>Integration tests are in the <code>src/__tests__/integration</code> directory.</p>
				<p>They require a Zeebe broker to run. You can run them using the <a href="https://circleci.com/docs/2.0/local-cli/">Circle CI CLI</a>:</p>
				<pre><code class="language-bash">circleci <span class="hljs-built_in">local</span> execute -c .circleci/config.yml --job <span class="hljs-built_in">test</span></code></pre>
				<p>Or you can start a dockerised broker:</p>
				<pre><code class="language-bash"><span class="hljs-built_in">cd</span> docker
docker-compose up</code></pre>
				<p>And then run them manually:</p>
				<pre><code class="language-bash">npm run <span class="hljs-built_in">test</span>:integration</code></pre>
				<p>For the failure test, you need to run Operate (<a href="https://github.com/zeebe-io/zeebe-docker-compose/blob/master/operate/docker-compose.yml">docker-compose config</a>) and manually verify that an incident has been raised at <a href="http://localhost:8080">http://localhost:8080</a>.</p>
				<h3 id="writing-tests">Writing Tests</h3>
				<p>Zeebe is inherently stateful, so integration tests need to be carefully isolated so that workers from one test do not service tasks in another test. Jest runs tests in a random order, so intermittent failures are the outcome of tests that mutate shared state.</p>
				<p>For each feature:</p>
				<ul>
					<li>Use a unique bpmn process, named the same as the test file. Don&#39;t reuse processes between tests, because they are tightly coupled.</li>
					<li>Name the task types with a namespace that matches the test name. This avoids workers from one test servicing tasks from another test, which causes unpredictable behaviour.</li>
					<li>Cancel any workflows that do not run to completion in an <code>AfterAll</code> or <code>AfterEach</code> block. This avoids subsequent test runs interacting with workflows from a previous test run.</li>
					<li>Ensure that there no Active workflows in the engine after running the integration tests have run. This manual check is to verify that there is no left-over state. (Note one exception: the Raise Incident test leaves the workflow open for manual verification in Operate).</li>
				</ul>
				<h2 id="contributors">Contributors</h2>
				<table>
					<thead>
						<tr>
							<th>Name</th>
						</tr>
					</thead>
					<tbody><tr>
							<td><strong><a href="https://github.com/jwulf">Josh Wulf</a></strong></td>
						</tr>
						<tr>
							<td><strong><a href="https://github.com/ColRad">Colin Raddatz</a></strong></td>
						</tr>
						<tr>
							<td><strong><a href="https://github.com/BrighTide">Jarred Filmer</a></strong></td>
						</tr>
						<tr>
							<td><strong><a href="https://github.com/s3than">Timothy Colbert</a></strong></td>
						</tr>
						<tr>
							<td><strong><a href="https://github.com/OlivierAlbertini">Olivier Albertini</a></strong></td>
						</tr>
				</tbody></table>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-enum">
						<a href="enums/partitionbrokerrole.html" class="tsd-kind-icon">Partition<wbr>Broker<wbr>Role</a>
					</li>
					<li class=" tsd-kind-enum">
						<a href="enums/resourcetype.html" class="tsd-kind-icon">Resource<wbr>Type</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/bpmnparser.html" class="tsd-kind-icon">Bpmn<wbr>Parser</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/configurationhydrator.html" class="tsd-kind-icon">Configuration<wbr>Hydrator</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/grpcclient.html" class="tsd-kind-icon">GRPCClient</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/mockstdout.html" class="tsd-kind-icon">Mock<wbr>Std<wbr>Out</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/oauthprovider.html" class="tsd-kind-icon">OAuth<wbr>Provider</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/utils.html" class="tsd-kind-icon">Utils</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/zbclient.html" class="tsd-kind-icon">ZBClient</a>
					</li>
					<li class=" tsd-kind-class">
						<a href="classes/zblogger.html" class="tsd-kind-icon">ZBLogger</a>
					</li>
					<li class=" tsd-kind-class tsd-has-type-parameter">
						<a href="classes/zbworker.html" class="tsd-kind-icon">ZBWorker</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/activatejobsrequest.html" class="tsd-kind-icon">Activate<wbr>Jobs<wbr>Request</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/activatejobsresponse.html" class="tsd-kind-icon">Activate<wbr>Jobs<wbr>Response</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/activatedjob.html" class="tsd-kind-icon">Activated<wbr>Job</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/brokerinfo.html" class="tsd-kind-icon">Broker<wbr>Info</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/camundacloudconfig.html" class="tsd-kind-icon">Camunda<wbr>Cloud<wbr>Config</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/completefn.html" class="tsd-kind-icon">Complete<wbr>Fn</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/completejobrequest.html" class="tsd-kind-icon">Complete<wbr>Job<wbr>Request</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/createworkflowinstancerequest.html" class="tsd-kind-icon">Create<wbr>Workflow<wbr>Instance<wbr>Request</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/createworkflowinstanceresponse.html" class="tsd-kind-icon">Create<wbr>Workflow<wbr>Instance<wbr>Response</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/deployworkflowrequest.html" class="tsd-kind-icon">Deploy<wbr>Workflow<wbr>Request</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/deployworkflowresponse.html" class="tsd-kind-icon">Deploy<wbr>Workflow<wbr>Response</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/failjobrequest.html" class="tsd-kind-icon">Fail<wbr>Job<wbr>Request</a>
					</li>
					<li class=" tsd-kind-interface tsd-is-not-exported">
						<a href="interfaces/grpcclientextendedoptions.html" class="tsd-kind-icon">GRPCClient<wbr>Extended<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/genericcustomheadershape.html" class="tsd-kind-icon">Generic<wbr>Custom<wbr>Header<wbr>Shape</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/genericworkerinputvariables.html" class="tsd-kind-icon">Generic<wbr>Worker<wbr>Input<wbr>Variables</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/genericworkeroutputvariables.html" class="tsd-kind-icon">Generic<wbr>Worker<wbr>Output<wbr>Variables</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/genericworkflowvariables.html" class="tsd-kind-icon">Generic<wbr>Workflow<wbr>Variables</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/getworkflowrequestwithbpmnprocessid.html" class="tsd-kind-icon">Get<wbr>Workflow<wbr>Request<wbr>With<wbr>Bpmn<wbr>Process<wbr>Id</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/getworkflowrequestwithworkflowkey.html" class="tsd-kind-icon">Get<wbr>Workflow<wbr>Request<wbr>With<wbr>Workflow<wbr>Key</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/getworkflowresponse.html" class="tsd-kind-icon">Get<wbr>Workflow<wbr>Response</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/job.html" class="tsd-kind-icon">Job</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/keyedobject.html" class="tsd-kind-icon">Keyed<wbr>Object</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/listworkflowresponse.html" class="tsd-kind-icon">List<wbr>Workflow<wbr>Response</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/oauthproviderconfig.html" class="tsd-kind-icon">OAuth<wbr>Provider<wbr>Config</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/operationoptionsnoretry.html" class="tsd-kind-icon">Operation<wbr>Options<wbr>NoRetry</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/operationoptionswithretry.html" class="tsd-kind-icon">Operation<wbr>Options<wbr>With<wbr>Retry</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/partition.html" class="tsd-kind-icon">Partition</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/publishmessagerequest.html" class="tsd-kind-icon">Publish<wbr>Message<wbr>Request</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/publishstartmessagerequest.html" class="tsd-kind-icon">Publish<wbr>Start<wbr>Message<wbr>Request</a>
					</li>
					<li class=" tsd-kind-interface tsd-has-type-parameter">
						<a href="interfaces/setvariablesrequest.html" class="tsd-kind-icon">Set<wbr>Variables<wbr>Request</a>
					</li>
					<li class=" tsd-kind-interface tsd-is-not-exported">
						<a href="interfaces/token.html" class="tsd-kind-icon">Token</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/topologyresponse.html" class="tsd-kind-icon">Topology<wbr>Response</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/updatejobretriesrequest.html" class="tsd-kind-icon">Update<wbr>Job<wbr>Retries<wbr>Request</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/workflowmetadata.html" class="tsd-kind-icon">Workflow<wbr>Metadata</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/workflowrequestobject.html" class="tsd-kind-icon">Workflow<wbr>Request<wbr>Object</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/zbclientoptions.html" class="tsd-kind-icon">ZBClient<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface tsd-is-not-exported">
						<a href="interfaces/zbgrpc.html" class="tsd-kind-icon">ZBGRPC</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/zbworkerloggeroptions.html" class="tsd-kind-icon">ZBWorker<wbr>Logger<wbr>Options</a>
					</li>
					<li class=" tsd-kind-interface">
						<a href="interfaces/zbworkeroptions.html" class="tsd-kind-icon">ZBWorker<wbr>Options</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#connectionerrorhandler" class="tsd-kind-icon">Connection<wbr>Error<wbr>Handler</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#getworkflowrequest" class="tsd-kind-icon">Get<wbr>Workflow<wbr>Request</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#loglevel" class="tsd-kind-icon">Loglevel</a>
					</li>
					<li class=" tsd-kind-type-alias">
						<a href="globals.html#operationoptions" class="tsd-kind-icon">Operation<wbr>Options</a>
					</li>
					<li class=" tsd-kind-type-alias tsd-has-type-parameter">
						<a href="globals.html#zbworkertaskhandler" class="tsd-kind-icon">ZBWorker<wbr>Task<wbr>Handler</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#a" class="tsd-kind-icon">a</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#connectivitystate" class="tsd-kind-icon">connectivity<wbr>State</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#homedir" class="tsd-kind-icon">homedir</a>
					</li>
					<li class=" tsd-kind-variable tsd-is-not-exported">
						<a href="globals.html#idcolors" class="tsd-kind-icon">id<wbr>Colors</a>
					</li>
					<li class=" tsd-kind-function tsd-is-not-exported">
						<a href="globals.html#getsafename" class="tsd-kind-icon">get<wbr>Safe<wbr>Name</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#parsepayload" class="tsd-kind-icon">parse<wbr>Payload</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#parsevariables" class="tsd-kind-icon">parse<wbr>Variables</a>
					</li>
					<li class=" tsd-kind-function">
						<a href="globals.html#stringifypayload" class="tsd-kind-icon">stringify<wbr>Payload</a>
					</li>
					<li class=" tsd-kind-function tsd-has-type-parameter">
						<a href="globals.html#stringifyvariables" class="tsd-kind-icon">stringify<wbr>Variables</a>
					</li>
					<li class=" tsd-kind-object-literal tsd-is-not-exported">
						<a href="globals.html#grpcerror" class="tsd-kind-icon">Grpc<wbr>Error</a>
					</li>
					<li class=" tsd-kind-object-literal tsd-is-not-exported">
						<a href="globals.html#grpcstate" class="tsd-kind-icon">Grpc<wbr>State</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>